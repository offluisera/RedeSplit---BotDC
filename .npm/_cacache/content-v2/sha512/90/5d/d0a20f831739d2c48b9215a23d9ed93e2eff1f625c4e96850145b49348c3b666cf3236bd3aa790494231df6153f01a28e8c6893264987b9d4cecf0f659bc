{"_id":"nodemark","_rev":"2-0b8995caed7566c973d4c4e6d7f9df8f","name":"nodemark","description":"A modern benchmarking library for Node.js","dist-tags":{"latest":"0.3.0"},"versions":{"0.2.0":{"name":"nodemark","version":"0.2.0","description":"A modern benchmarking library for Node.js","main":"index.js","scripts":{"test":"$(npm bin)/mocha --exit"},"repository":{"type":"git","url":"git+https://github.com/JoshuaWise/nodemark.git"},"keywords":["benchmark","performance","perf","benchmarkjs","speed","test"],"author":{"name":"Joshua Wise","email":"joshuathomaswise@gmail.com"},"license":"MIT","bugs":{"url":"https://github.com/JoshuaWise/nodemark/issues"},"homepage":"https://github.com/JoshuaWise/nodemark#readme","gitHead":"f734ff9d351bf2be7e458115dc592abfec6ab882","_id":"nodemark@0.2.0","_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"joshuawise","email":"joshuathomaswise@gmail.com"},"dist":{"integrity":"sha512-gZDQu645o8GWdGto8K8iKkqBjtEeqE/tzj5GWmDf1aLgzO/Etbai9TMUlZSakj2/8hBGuN+7rtuIUrAImuC40A==","shasum":"6585bbadc8714076b898685f9b855415d1414949","tarball":"https://registry.npmjs.org/nodemark/-/nodemark-0.2.0.tgz","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCv03hl9Ms7e1fTgIA95/OYP5BQWSfoSFpLFM4sn5MGnQIgT10NibBlHEEF1v22OgdhTywK8AZSsZno8TIRrTd/YAE="}]},"maintainers":[{"name":"joshuawise","email":"joshuathomaswise@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/nodemark-0.2.0.tgz_1517348632201_0.49235424189828336"}},"0.3.0":{"name":"nodemark","version":"0.3.0","description":"A modern benchmarking library for Node.js","main":"index.js","scripts":{"test":"$(npm bin)/mocha --exit"},"repository":{"type":"git","url":"git+https://github.com/JoshuaWise/nodemark.git"},"keywords":["benchmark","performance","perf","benchmarkjs","speed","test"],"author":{"name":"Joshua Wise","email":"joshuathomaswise@gmail.com"},"license":"MIT","bugs":{"url":"https://github.com/JoshuaWise/nodemark/issues"},"homepage":"https://github.com/JoshuaWise/nodemark#readme","devDependencies":{"chai":"^4.1.2","mocha":"^5.0.0"},"gitHead":"63e0b2692c9758994c311088e0331f0015e4dc36","_id":"nodemark@0.3.0","_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"joshuawise","email":"joshuathomaswise@gmail.com"},"dist":{"integrity":"sha512-ehT+NfV5liLY1sZVcosWiCViWHltQTnjsh/7GYkMkirzuyYw/K2VAbgwEIldAM1e9LJ3coGF6uBlTw1/EdZ1XA==","shasum":"d824cbcb12ffec7aa1b4c2c767785bc34e76790a","tarball":"https://registry.npmjs.org/nodemark/-/nodemark-0.3.0.tgz","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBHjQ+CtRn0RD8wZRqligaiNLTXx7XOko6N7Uh9xpjR5AiEAoVEXGExoI5jbixwFEld3wCW8Ze6+q/7bkx7qmSO3R+Q="}]},"maintainers":[{"name":"joshuawise","email":"joshuathomaswise@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/nodemark-0.3.0.tgz_1517456765926_0.7764604261610657"}}},"readme":"# nodemark [![Build Status](https://travis-ci.org/JoshuaWise/nodemark.svg?branch=master)](https://travis-ci.org/JoshuaWise/nodemark)\nA modern benchmarking library for Node.js, capable of generating statistically significant results.\n\n## Installation\n```\nnpm install --save-dev nodemark\n```\n\n## Usage\n```js\nconst benchmark = require('nodemark');\n\nconst result = benchmark(myFunction, setupFunction);\nconsole.log(result); // => 14,114,886 ops/sec Â±0.58% (7906233 samples)\nconsole.log(result.nanoseconds()); // => 71\n```\n\n## Statistical Significance\n\nIn benchmarking, it's important to generate statistically significant results. Thankfully, `nodemark` makes this easy:\n\n* The *margin of error* is calculated for you.\n* The noise caused by `nodemark` is factored out of the results.\n* The garbage collector is manipulated to prevent early runs from having an unfair advantage.\n* Executions done before v8 has a chance to optimize things ([JIT](https://en.wikipedia.org/wiki/Just-in-time_compilation)) are ignored.\n\nThe combination of these things makes it a highly accurate measuring device. However, any benchmark done in JavaScript has its limits. If the average time measured by a benchmark is too small to be reliable (< 10ns), the results will be `NaN` in order to avoid providing misleading information.\n\n# API\n\n## benchmark(*subject*, [*setup*, [*duration*]]) -> *benchmarkResult*\n\nRuns a new benchmark. This measures the performance of the `subject` function. If a `setup` function is provided, it will be invoked before every execution of `subject`.\n\nBy default, the benchmark runs for about 3 seconds, but this can be overridden by passing a `duration` number (in milliseconds). Regardless of the desired duration, the benchmark will not finish until the `subject` has been run at least 10 times.\n\nBoth `subject` and `setup` can run asynchronously by declaring a callback argument in their signature. If you do this, you must invoke the callback to indicate that the operation is complete. When running an asyncronous benchmark, this function returns a promise. However, because `subject` and `setup` use callbacks rather than promises, synchronous errors will not automatically be caught.\n\n```js\nbenchmark(callback => fs.readFile('foo.txt', callback))\n  .then(console.log);\n```\n\n> There is no plan to support promises in `subject` and `setup` because it would cause too much overhead and yield inaccurate results.\n\n## class *BenchmarkResult*\n\nEach benchmark returns an immutable object describing the result of that benchmark. It has five properties:\n\n* `mean`, the average measured time in nanoseconds\n* `error`, the margin of error as a ratio of the mean\n* `max`, the fastest measured time in nanoseconds\n* `min`, the slowest measured time in nanoseconds\n* `count`, the number of times the subject was invoked and measured\n\n### .nanoseconds([*precision*]) -> *number*\n\nReturns `this.mean`, rounded to the nearest whole number or the number or decimal places specified by `precision`.\n\n### .microseconds([*precision*]) -> *number*\n\nSame as [.nanoseconds()](#nanosecondsprecision---number), but the value is in microseconds.\n\n### .milliseconds([*precision*]) -> *number*\n\nSame as [.nanoseconds()](#nanosecondsprecision---number), but the value is in milliseconds.\n\n### .seconds([*precision*]) -> *number*\n\nSame as [.nanoseconds()](#nanosecondsprecision---number), but the value is in seconds.\n\n### .hz([*precision*]) -> *number*\n\nReturns the average number of executions per second, rounded to the nearest whole number or the number of decimal places specified by `precision`.\n\n### .sd([*precision*]) -> *number*\n\nReturns the standard deviation in nanoseconds, rounded to the nearest whole number or the number of decimal places specified by `precision`.\n\n### .toString([*format*]) -> *number*\n\nReturns a nicely formatted string describing the result of the benchmark. By default, the `\"hz\"` format is used, which displays ops/sec, but you can optionally specify `\"nanoseconds\"`, `\"microseconds\"`, `\"milliseconds\"`, or `\"seconds\"` to change the displayed information.\n\n## License\n\n[MIT](https://github.com/JoshuaWise/nodemark/blob/master/LICENSE)\n","maintainers":[{"name":"joshuawise","email":"joshuathomaswise@gmail.com"}],"time":{"modified":"2022-05-11T07:59:01.025Z","created":"2018-01-30T21:43:52.258Z","0.2.0":"2018-01-30T21:43:52.258Z","0.3.0":"2018-02-01T03:46:06.813Z"},"homepage":"https://github.com/JoshuaWise/nodemark#readme","keywords":["benchmark","performance","perf","benchmarkjs","speed","test"],"repository":{"type":"git","url":"git+https://github.com/JoshuaWise/nodemark.git"},"author":{"name":"Joshua Wise","email":"joshuathomaswise@gmail.com"},"bugs":{"url":"https://github.com/JoshuaWise/nodemark/issues"},"license":"MIT","readmeFilename":"README.md"}